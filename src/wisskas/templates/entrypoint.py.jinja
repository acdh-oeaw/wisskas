{%- if logging -%}
import logging
{% endif -%}
from os import path
from typing import Annotated

from fastapi import FastAPI, Query, Request
{%- if cors %}
from fastapi.middleware.cors import CORSMiddleware
{%- endif %}
from fastapi.responses import PlainTextResponse
{%- if git %}
from git import Repo
{%- endif %}
from pydantic import Field
from rdfproxy import Page, QueryParameters, SPARQLModelAdapter
from rdfproxy.utils.exceptions import NoResultsFound
from rdfproxy.utils.utils import ModelSPARQLMap

{% for endpoint in endpoints.values() | sort(attribute="filename") -%}
from {{ endpoint.filename }} import {{ endpoint.class_name }}
{% endfor %}

{% if logging -%}
logging.basicConfig(level=logging.DEBUG)
{% endif -%}

app = FastAPI(debug=True)

{% if cors -%}
app.add_middleware(
    CORSMiddleware,
    allow_origins={{ cors.origins | default(["*"], true) | tojson }},
    allow_credentials=True,
    allow_methods={{ cors.methods | default(["*"], true) | tojson }},
    allow_headers={{ cors.headers | default(["*"], true) | tojson }},
)

{% endif %}

{%- if git %}
# The automatic health check endpoint is /. The return code has to be 200 or 30x.
@app.get("/", include_in_schema=False)
def version():
    repo = Repo(search_parent_directories=True)
    return {"version": repo.git.describe(tags=True, dirty=True, always=True)}
{% endif %}

def load_query(name):
    with open(f"{path.dirname(path.realpath(__file__))}/{name}.rq") as query:
        return query.read().replace("\n ", " ")


@app.exception_handler(NoResultsFound)
def noresultsfound_exception_handler(_: Request, exc: NoResultsFound):
    return PlainTextResponse(status_code=404, content=str(exc))
    # content="\n".join(traceback.format_exception(exc))


class DefaultQueryParameters(QueryParameters):
    size: int = Field(default={{ page_size }}, ge=1)

class FilterableQueryParameters(DefaultQueryParameters):
    query: str | None = None

{% for url, endpoint in endpoints | dictsort %}
{%- if endpoint.item_key %}
@app.get("{{ url }}")
def {{ endpoint.filename }}(id: str) -> {{ endpoint.class_name }}:
{% else %}
@app.get("{{ url }}")
def {{ endpoint.filename }}(params: Annotated[{% if endpoint.filterable_fields %}Filterable{% else %}Default{% endif %}QueryParameters[{{ endpoint.class_name }}], Query()]) -> Page[{{ endpoint.class_name }}]:
{% endif %}
    query = load_query("{{ endpoint.filename }}")
    {%- if endpoint.filterable_fields %}
    if params.query:
        bindings = ModelSPARQLMap({{ endpoint.class_name }}, True)
        fields = [ bindings[f] for f in {{ endpoint.filterable_fields }}]
        query = query[:-2] + " FILTER ( " + " || ".join(f'CONTAINS(?{f}, "{q}")' for f in fields for q in params.query.split(' ')) + ") }"
    {%- endif %}
    adapter = SPARQLModelAdapter(
        target="{{ backend_address }}",
        query=query,
        model={{ endpoint.class_name }},
        {% if httpx_args -%}
        httpx_aclient_params={{ httpx_args }}
        {%- endif -%}
    )

{%- if endpoint.item_key %}
    return adapter.get_item(**{ "{{ endpoint.item_key }}": id})
{% else %}
    return adapter.get_page(params)
{% endif %}

{%- endfor %}

{% if counts %}
@app.get("/counts")
def counts():
    """Return item counts for all listing endpoints"""
    return {
    {%- for url, endpoint in endpoints | dictsort -%}
        {%- if not endpoint.item_key %}
        "{{ url }}": {{ endpoint.filename }}(params=FilterableQueryParameters(size=1)).total,
        {%- endif -%}
    {%- endfor %}
    }
{% endif %}
